# ✅ 1. Git 이란?

깃은 2005년 리눅스 개발자인 ‘리누스 베네딕트 토발즈’가 개발한 대표적인 분산형 버전 관리 시스템이다. 

분산 버전관리 시스템 (Distributed Version Control System- DVCS)으로, 컴퓨터 파일의 변경사항을 추적하고 여러명의 사용자들 간에 파일에 대한 작업을 조율하는데 사용된다 .

원격 저장소와는 별개로 개발자 각각의 로컬 컴퓨터와 동일한 복제본 소스 코드를 저장할 수 있도록 만들어진 저장소이다. 또한, 네트워크나 인터넷이 연결되어 있지 않은 상태에서도 로컬 컴퓨터와 소스 코드만으로 버전관리가 가능하며, 인터넷이 연결되어 있을 땐 동기화 작업을 하거나, 많은 개발자의 저장소와 연결할 수 있다. 

깃은 크게 **워킹 디렉터리, 스테이지 영역, 저장소**로 구분할 수 있다. 

워킹 디렉터리는 ‘작업하는 공간’, 스테이지 영역은 ‘임시로 저장하는 공간’, 저장소는 ‘실제로 저장해 기록하는 공간’ 을 의미한다.

**워킹 디렉터리**

로컬 저장소에 접근할 수 있고, 실제로 파일을 생성하고 수정하는 공간이다. 

워킹 디렉터리에 존재하는 파일들은 깃이 자동으로 추적관리를 하지 않는다. 

깃에서는 untracked (추적되지 않음) 상태로 처리된다. git add 명령어로 tracked 상태로 바꿔야 깃에서 관리가 가능해진다. 

**스테이지 영역**

워킹 디렉터리에서 제출된 tracked 파일들을 관리한다. 

stage 상태와 unstage 상태로 구분되고, 파일의 콘텐츠 내용을 직접 가지지는 않고, 단지 커밋하려는 파일의 추적 상태 정보들만 기록한다.  status 명령어로 상태확인이 가능하다. 

status 명령어를 통해 Untracked files 을 다시 stage 해주면 된다. 워킹 디렉터리에 새로운 파일이 등록되었다고 알려 주는 것이다.

### 1-1. 깃의 동작과 명령어 정리

---

### 🎯초기화 : 폴더를 깃 저장소로 변경한다.

#### 기초 환경설정

```jsx
$ git config --global user.name "name"
$ git config --global user.email "email"
```

깃을 설치하면 환경설정을 먼저 해야한다. 

유저 이름과 깃허브(원격저장소)에 가입했던 혹은 원격저장소를 연결시켜줄 이메일을 작성하면 된다. 

```jsx
$ git config --list
```

환경설정이 완료되면, 위처럼 목록화하여 환경설정을 살펴볼 수 있다. 

- 로컬 저장소에서 새로 생성
    
    VCS 관리를 위한 숨겨진 영역을 생성하는 작업을 의미한다 . 일반 폴더에서 깃 저장소로 사용하기 위한 작업을 진행해야 한다.  프로젝트를 진행하고 있는 폴더나, 새로운 폴더를  생성하여 진행한다. 
    
    ```jsx
    $ git init (경로명)
    
    경로명을 입력하지 않으면, 현재 폴더 위치에서 초기화
    ```
    
    저장소를 생성한 위치에 .git 으로 숨겨진 폴더가 생성된 것을 확인할 수 있다.  
    
    ```jsx
    	$ git remote add 원격저장소별칭 원격저장소주소(repository)
    ```
    
    로컬저장소를 완료하면, 원격저장소에도 연결해줘야 한다.
    
- 원격 저장소에서 가져오기
    
    원격저장소에 작업된 파일들이 존재하고, 로컬에서 새롭게 작업을 진행할 경우이다. 
    
    ```jsx
    $ git clone 원격저장소주소(repository) 
    ```
    
    바로 원격저장소와 연결이 이루어지고, 작업된 파일들을 오류없이 로컬저장소에도 저장할 수 있다. 
    
- 동기화상태 이후, 파일을 수정한 경우
    
    이 경우는 이미 원격저장소와 로컬 저장소가 연결이 되어 있는 상태이다. 
    
    협업을 진행하는 경우에는 다른 사람이 파일을 수정하는 경우가 많다. 이럴 때는 다른 사람이 작업한 원격저장소에서 파일을 가져와서 최신화를 진행해야 한다. 
    
    ```jsx
    $ git pull 
    ```
    
    원격 저장소로부터 가져오는 것이고,
    
    ```jsx
    $ git pull 원격저장소별칭 브랜치명 
    ```
    
    위의 명령어는 원격저장소의 특정 브랜치로부터 작업된 파일을 가져올 수 있다. 
    
    ```jsx
    $ git fetch
    ```
    
    위와 같이 작성하게 되면, 원격저장소로부터 변경된 사항을 가져온다. 병합을 진행하지는 않는다. 
    
    아래는 수정된 파일과 로컬저장소의 파일을 비교하여 수정된 점을 확인하는 작업 명령어이다. 
    
    ```jsx
    $ git diff 
    ```
---    

### 🎯커밋 : 변경된 코드의 이력을 기록한다.

워킹 디렉터리에 있는 파일들을 아래 명령어를 통해 스테이지 영역으로 등록한다. 

정확하게 말하면 워킹 디렉터리에 있는 파일은 스테이지 영역으로 복사하는 것을 의미한다. 

```jsx
$ git add .  OR  git add 파일이름 
```

스테이지 영역으로 추가되면, 깃은 파일의 해시를 계산하여 저장한다. 저장된 파일들은 깃으로부터 추적이 되고, 관리될 수 있는 준비를 마친다.  이 상태를 tracked 상태라고 표현한다. 

> 🌈  상태
> 
> - tracked
>     - git에 의해 추적되는 상태
> - untracked
>     - git에 의해 추적되고 있지 않은 상태
> - modified
>     - git에 의해 추적되고 있으며, git의 관리내용이 실제 객체와 다른 상태
>     - untracked상태이며, 파일을 수정한 상태
>     - 반드시 등록 명령(add)로 다시 스테이지 상태로 재등록해야 tracked상태로 변환됨.
> - unmodified
>     - git에 의해 추적되고 있으며, git의 관리 내용과 실체 객체가 일치한 상태.
>     - 즉, tracked상태이며, 아무런 수정을 하지 않은 상태

아래의 방법은 워킹 디렉터리와 스테이지 영역을 서로 왔다 갔다 할 수 있는 방법이다. 

즉, tracked 상태에서 untracked 상태로 변경하는 명령어다. 

```jsx
$ git rm --cached 파일이름 
```

커밋을 진행하기 위해서는 파일이 모두 tracked 상태여야 한다. 만약 수정한 파일이 존재한다면, 

```jsx
$ git status
```

status 명령어를 통해 파일의 상태를 확인해야 한다. 

```jsx
$ git commit 
```

커밋 작업을 할 때는 스테이지 영역에 있는 파일들만 커밋 작업이 가능하다. 

파일의 상태를 확인해야 하는 이유가 그러한 이유이다. 파일이 스테이지 영역에 등록되어 있는지, 

수정된 파일인지 아닌지 확인하고 커밋작업을 진행해야 한다. 

커밋이 완료되면, 최종 커밋된 지점을 가리키는 포인터인 HEAD 와 스테이지 영역 간의 차이를 비교하여 새로운 객체를 생성한다. 처음 커밋을 진행했을 땐, HEAD 포인터가 없다. 최소한 한번 이상 해야 최종 커밋 지점으로 HEAD포인터가 이동하게 된다.  즉, 마지막 커밋 위치를 HEAD의 포인터 위치라고 보면 된다. 

이러한 커밋의 변화를 깃 저장소에서는 영구적으로 기록한다. 파일을 복사하여 스테이지 영역에 올리던 방식과는 다르게, **스냅샷**  방식을 이용한다. 

스냅샷은 마치 변화된 부분만 찾아 사진을 찍는 것과 같다고 하여 스냅샷 방식이라고 하고, 변화된 부분은 HEAD가 가리키는 커밋을 뜻한다. 스테이지 영역과 비교하여 새로운 커밋으로 다시 스냅샷을 찍고, 이를 누적시키는 것이다. 이처럼 깃은 스냅샷 방식을 이용하여 빠르게 버전의 차이점을 처리하고, 용량을 적게 사용한다. 

커밋을 진행할 때는 이를 구별할 수 있는 메세지를 같이 작성해야 한다. 이 메세지를 커밋 메세지라고 한다.  위의 명령어만 단독으로 하면, vi 에디터가 열러 메세지를 작성할 수 있고,  옵션을 사용하여 커밋과 동시에 메세지를 전달할 수 있다.

```jsx
$ git commit -a       // 파일 등록과 커밋을 동시에 진행 
$ git commit -m "메세지"    // vi 에딭터 대신 메세지 바로 작성
```

커밋 후, 커밋 기록을 확인해야 할 수 있다. 

```jsx
$ git log
```

최신 기록부터 내림차순으로 정렬되어 출력 되어진다. 

커밋을 진행 후, 파일을 이전 상태에서 수정을 진행해야 한다면 ,  다음과 같이 사용할 수 있다. 

```jsx
$ git checkout --수정파일이름 
```

그러나 이 명령어는 돌아간 시점 이후에 작업된 내역들은 모두 삭제한다 . 

---

### 🎯브랜치 : 분리 격리된 코드 이력을 기록한다.

큰 나무 줄기에서 작은 줄기가 뻗어 나오는 것처럼 저장 공간 하나에서 가상의 또 다른 저장 공간을 만드는 것이다. 

```jsx
$ git branch 
```

branch 명령어로 현재 브랜치를 확인할 수 있다. 

```jsx
// 커밋ID 인자값을 기준으로 브랜치를 생성
$ git branch 브랜치이름 커밋ID 

// 마지막 커밋을 기준으로 브랜치 생성
$ git branch 브랜치이름 
```

브랜치 간의 이동이 필요할 때는 checkout 명령어를 사용한다. 

```jsx
$ git checkout 브랜치이름 
```

이때 주의해야 할 점이 몇 가지 있다.

우선 , HEAD 정보는 브랜치의 마지막 커밋을 따라간다. 즉, 브랜치가 이동하면 HEAD 포인터도 함께 이동하기 때문에, 기존 브랜치의 워킹 디렉터리에서 작업했던 파일들이 있다면, 정리하고 브랜치를 변경해야 한다. 

원격저장소에 브랜치를 생성하는 명령어다. 

```jsx
$ git checkout -b 브랜치명 
```

---

### 🎯브랜치 삭제

브랜치를 병합한 후에는, 병합된 브랜치를  삭제한다. 

```jsx
$ git branch -d 브랜치명 
```
---

### 🎯푸시 : 로컬 저장소의 이력을 서버로 전송 및 공유한다.

저장소는 원격저장소로 커밋된 파일들이 존재하는 공간이다. 

푸시는 이 원격저장소로 파일들을 업로드하는 동작을 뜻한다. 

```jsx
$ git remote -v
```

로컬 저장소에서 작업된 파일이 어떤 원격저장소와 연결이 되어있는지 확인 할 수 있는 명령어이다. 

원격 저장소로 로컬 깃 저장소의 내용을 전송할 때는 다음과 같이 사용한다. 

```jsx
$ git push 원격저장소별칭 브랜치명 ( 로컬브랜치명:원격브랜치명)
```

원격저장소에 푸시하면 로컬저장소, 원격저장소 2개의 장소에 소스코드가 저장이 된다. 

원래는 로컬브랜치명과 원격브랜치명이 동일하게 하는 가정 하에, `브랜치명` 만 적으면 되는데, 

로컬브랜치명과 원격브랜치명이 다를 경우에는 위의 괄호처럼 작성하면 된다. 

```jsx
$ git push -u 원격저장소별칭 브랜치명 
```

위의 명령어는 원격저장소의 브랜치 생성과 동시에, push 까지 진행할 수 있는 명령어이다. 

---

### 🎯병합 :기존 이력과 분리된 이력을 통합한다.

깃의 병합은 브랜치를 기준으로 실행한다. 분리된 각각의 브랜치에서 수정된 사항을 하나의 브랜치로 병합하는 작업이다. 깃은 이 수정된 사항을 발견하여 자동으로 코드 내용을 병합한다. 

각 브랜치를 자동 병합하는 형태로 깃은 병합을 진행하는데, 이때 파일들은 같은 로컬 저장소에 있어야 하고, 수정 작업이 있어야 진행이 가능해진다. 병합을 할 때는 상대적인 기준을 판별하는 알고리즘들이 존재하고, 충돌없이 병합하려면 ‘Fast-Forward 병합’과 ‘3-way 병합’ 의 차이를 먼저 알아야 한다. 

- Fast-Forward 병합
    - 순차적 커밋에 맞추어 병합을 처리하는 방식
    - 주로 혼자 개발할 때 많이 사용
    - 전체 커밋 플로우관점에서 브랜치가 분기되지만, 모든 변경사항은 순차적 진행
- 3-way 병합
    - 여러 개발자와 협업으로 작업하는 경우 많이 사용
    - 공통 조상 커밋, 2개의 브랜치 커밋으로 이루어져 병합하는 방식
    - 병합 완료 후, 새로운 병합 커밋을 생성
    

```jsx
$ git merge 브랜치명 
```

이때, 브랜치명은 자신이 병합하려는 브랜치명이어야 한다.

즉, 현재 작업하고 있는 브랜치가 master 이고, 병합하려는 브랜치가 feature라면 

```jsx
$ git branch feature
```

가 될 것이다. 

깃이 자동으로 병합을 진행하지만, 사람들과 협업하여 진행하게 되면, 코드 충돌이 발생하는 경우도 있다. 주로, 같은 위치의 코드를 수정할 때 자주 발생한다. 

다른 위치의 코드를 수정했다면 수정한 것으로 병합을 진행하지만, 같은 코드를 동시에 수정하면 깃은 어떤 코드를 병합해야할지 알 수가 없기 때문에 병합에 충돌이 생긴다. 

이때는 

```jsx
$ git ls-files -u
```

명령어로 확인이 가능하고, 충돌을 해결한 후 위의 방법과 동일하게 다시 병합을 진행할 수 있다. 

수정을 하게 되면, modified상태로 되기 때문에 현재 워킹 디렉토리에 존재하게 되고, add 명령어를 통해서 스테이지 영역으로 올려 커밋을 진행하면 된다. 


# ✅ 2. GitHub 란 무엇인가?


- Git으로 관리하는 프로젝트를 올려 둘 수 있는 대표적인 Git 호스팅 사이트 중 하나
- 소프트웨어 개발 프로젝트를 위한 소스코드 관리서비스(원격저장소)
- 클라우드 방식으로 관리되는 버전관리시스템(VCS)
- 소스코드 열람 및 간단한 버그정리, 버전관리 그리고 sns기능도 있는 호스팅 플랫폼 서비스

### 📌 호스팅 사이트
- GitLab 
    - 공개저장소 비공개 저장소 생성이 모두 무료이다. 
- BitBucket
    - 사용자가 약 1000만명이다. 이슈 관련 시스템인 지라(Jira)를 만든 모기업에서 출시하여 지라와 연동이 쉽게 되고, github와 마찬가지로 공개저장소 비공개 저장소 모두 무료이다. 
